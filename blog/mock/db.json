{
    "posts": [
        {
            "id": 1,
            "title": "json-server",
            "author": "typicode"
        }
    ],
    "articles": [
        {
            "id": "article-1",
            "article_id": "article-1",
            "title": "for..in for..of forEach",
            "update_time": "2018-01-04",
            "category": "Javascript",
            "abstract": "## for...in for...in语句以任意顺序遍历一个对象的可枚举属性。对于每个不同的属性，语句都会被执行。 ### 语法 ```js for (variable in object) {...} ``` `variable`：在每次迭代时，将不同的 ..."
        },
        {
            "id": "article-2",
            "article_id": "article-2",
            "title": "一道JavaScript面试题",
            "update_time": "2018-01-08",
            "category": "面试 柯里化",
            "abstract": "题目如下将以下函数补充完整：function sum(a, b, c) { } function currying(fn) { } var curry = currying(sum); console.log(currying(sum, ..."
        },
        {
            "id": "article-3",
            "article_id": "article-3",
            "title": "React消息传递",
            "update_time": "2018-01-10",
            "category": "react",
            "abstract": "在React中，数据流动是单向的(单向数据流)，父组件通过props将数据传递到子组件，子组件根据父组件传递来的属性和组件内部状态来确定如何渲染。因为单向数据流的特性，父组件向子组件传递数据是很容易的，即通过props传递数据，且子组件不能修改自己的props ..."
        },
        {
            "id": "article-4",
            "article_id": "article-4",
            "title": "React事件系统",
            "update_time": "2018-01-18",
            "category": "react",
            "abstract": "简介原生DOM事件体系存在很多问题，譬如各浏览器之间存在差异、容易引起内存浪费、性能低下、JS操作DOM效率低等。为了解决这些问题，React实现了一套比较高效的事件合成系统，包括事件注册、存储、分发、重用等功能。与原生DOM事件体系相比，React事件合成系 ..."
        },
        {
            "id": "article-5",
            "article_id": "article-5",
            "title": "Immutable 详解",
            "update_time": "2018-02-18",
            "category": "javascript",
            "abstract": "## 数据类型 ECMAScript中的数据类型分为两类：简单数据类型（也称为基本数据类型）和复杂数据类型（对象）： - Primitive Data Types（基础数据类型）: String, Number, Boolean, Null, Undefine ..."
        },
        {
            "id": "article-6",
            "article_id": "article-6",
            "title": "React Fiber",
            "update_time": "2018-02-20",
            "category": "react",
            "abstract": "## 问题 ### Fiber的目标 > Increase its suitability for areas like animation, layout, and gestures. ### React Fiber > React Fiber is ..."
        }
    ],
    "article_detail": [
        {
            "id": "article-1",
            "title": "for..in for..of forEach",
            "update_time": "2018-01-04",
            "category": "Javascript",
            "body": "## for...in\n\nfor...in语句以任意顺序遍历一个对象的可枚举属性。对于每个不同的属性，语句都会被执行。\n\n### 语法\n```js\nfor (variable in object) {...}\n```\n`variable`：在每次迭代时，将不同的属性名分配给变量。  \n`object`：被迭代枚举其属性的对象。\n\n### 描述\n`for...in`循环只遍历可枚举属性，包括对象自身的可枚举属性，以及其原型链上的所有可枚举属性。\n\n#### 删除、添加、修改属性\n`for...in`循环以任意序迭代一个对象的属性，对属性的删除、添加、修改需要注意以下几个问题：\n- 如果一个属性在一次迭代中被修改，并在之后的迭代中被访问，那么再次被访问的值为修改之后的值；\n- 一个在被访问之前已经被删除的属性将不会在之后被访问；\n- 在迭代进行时被添加到对象的属性，可能在之后的迭代被访问，也可能被忽略；所以不能保证迭代时添加的属性一定能被访问到；\n- 因为迭代的顺序是不确定的，所以不能保证在迭代过程中被修改或被删除的属性会在修改或删除前还是修改或删除后被访问到（除非是正在被访问的属性）；\n- 所以，在迭代过程中最好不要在对象上进行添加、修改或者删除属性的操作，除非是对当前正在被访问的属性；\n\n#### 数组迭代\n`for...in`不应该用来迭代数组，因为通常情况下迭代数组时，顺序是很重要的，而数组索引只是具有整数名称的枚举属性，与通用对象属性相同，所以`for...in`不能保证有序迭代数组。\n\n另外，`for...in`将返回所有可枚举属性，包括非整数类型的属性以及继承自原型链上的属性。\n\n#### 仅迭代自身属性\n如果你只要考虑对象本身的属性，而不是它的原型，那么使用`getOwnPropertyNames()`或执行`hasOwnProperty()`来确定某属性是否是对象本身的属性\n```js\nfor (var prop in obj) {\n    if (obj.hasOwnProperty(prop)) {\n        console.log(prop);\n    } \n}\n```\n\n## for...of\n`for...of`语句是ES2015中新引入的，用于配合可迭代对象使用。\n\n`for...of`可以在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。\n\n### 语法\n```js\nfor (variable of iterable) {\n    //statements\n}\n```\n`variable`：在每次迭代中，将不同属性的**值**分配给变量。  \n`iterable`：可枚举其枚举属性的对象。\n\n### 示例\n```js\nlet iterable = [10, 20, 30];\n\nfor (const value of iterable) {\n    console.log(value);\n}\n// 10\n// 20\n// 30\n```\n```js\nlet iterable = 'boo';\n\nfor (let value of iterable) {\n   console.log(value);\n}\n// 'b'\n// 'o'\n// 'o'\n```\n```js\nlet iterable = new Map([['a', 1], ['b', 2], ['c', 3]]);\n\nfor (let entry of iterable) {\n  console.log(entry);\n}\n// ['a', 1]\n// ['b', 2]\n// ['c', 3]\n\nfor (let [key, value] of iterable) {\n  console.log(value);\n}\n// 1\n// 2\n// 3\n```\n```js\nlet iterable = new Set([1, 1, 2, 2, 3, 3]);\n\nfor (let value of iterable) {\n    console.log(value);\n}\n// 1\n// 2\n// 3\n```\n\n## forEach\n`forEach()`方法是在第五版本里被添加到`ECMA-262`标准的，它可以对数组的每个元素执行一次提供的函数。\n\n### 语法\n```js\narray.forEach(callback(currentValue, index, array){\n    //do something\n}, this)\n\narray.forEach(callback[, thisArg])\n```\n`callback`：为数组中每个元素执行的函数，该函数接收三个参数：\n- currentValue(当前值)：数组中正在处理的当前元素；\n- index(索引)：数组中正在处理的当前元素的索引；\n- array：forEach()方法正在操作的数组；\n\n`thisArg`：可选参数，当执行回调函数时用作this的值(参考对象)；\n\n### 语法\n`forEach`方法按升序为数组中含有效值的每一项执行一次callback 函数，那些已删除（使用delete方法等情况）或者未初始化的项将被跳过（但不包括那些值为 undefined 的项）（例如在稀疏数组上）。\n\ncallback函数会被依次传入三个参数：\n- 数组当前项的值\n- 数当前项的索引\n- 数组对象本身\n\n如果给forEach传递了thisArg参数，当调用时，它将被传给callback函数，作为它的this值。否则，将会传入undefined作为它的this值。\n\n`forEach`遍历的范围在第一次调用`callback`前就会确定。调用`forEach`后添加到数组中的项不会被`callback`访问到。如果已经存在的值被改变，则传递给`callback`的值是`forEach`遍历到它们那一刻的值。已删除的项不会被遍历到。如果已访问的元素在迭代时被删除了(例如使用 shift()) ，之后的元素将被跳过。\n\n`forEach()`为每个数组元素执行callback函数；不像`map()`或者`reduce()`，它总是返回`undefined`值，并且不可链式调用。\n\n**注意**：没有办法中止或者跳出forEach循环，除了抛出一个异常。如果你需要这样，使用forEach()方法是错误的，你可以用一个简单的循环作为替代。如果你正在测试一个数组里的元素是否符合某条件，且需要返回一个布尔值，那么可使用`Array.every`或`Array.some`。\n\n### 示例\n#### 打印数组内容\n```js\nfunction logArrayElements(element, index, array) {\n    console.log('a[' + index + '] = ' + element);\n}\n\n// 注意索引2被跳过了，因为在数组的这个位置没有项\n[2, 5, ,9].forEach(logArrayElements);\n\n// a[0] = 2\n// a[1] = 5\n// a[3] = 9\n\n[2, 5,' ,9].forEach(logArrayElements);\n// a[0] = 2\n// a[1] = 5\n// a[2] = \n// a[3] = 9\n\n[2, 5, undefined ,9].forEach(logArrayElements);\n// a[0] = 2\n// a[1] = 5\n// a[2] = undefined\n// a[3] = 9\n\nlet xxx;\n// undefined\n\n[2, 5, xxx ,9].forEach(logArrayElements);\n// a[0] = 2\n// a[1] = 5\n// a[2] = undefined\n// a[3] = 9\n```\n#### 使用thisArg\n```js\nfunction Counter() {\n    this.sum = 0;\n    this.count = 0;\n}\n\nCounter.prototype.add = function(array) {\n    array.forEach(function(entry) {\n        this.sum += entry;\n        ++this.count;\n    }, this);\n    //console.log(this);\n};\n\nvar obj = new Counter();\nobj.add([1, 3, 5, 7]);\n\nobj.count; \n// 4 === (1+1+1+1)\nobj.sum;\n// 16 === (1+3+5+7)\n```\n**注意**：如果使用箭头函数表达式传入函数参数，thisArg参数会被忽略，因为箭头函数在词法上绑定了this值。\n\n#### 对象复制函数\n```js\nfunction copy(obj) {\n    var copy = Object.create(Object.getPrototypeOf(obj));\n    var propNames = Object.getOwnPropertyNames(obj);\n\n    propNames.forEach(function(name) {\n        var desc = Object.getOwnPropertyDescriptor(obj, name);\n        Object.defineProperty(copy, name, desc);\n  });\n\n    return copy;\n}\n\nvar obj1 = { a: 1, b: 2 };\nvar obj2 = copy(obj1); // obj2 looks like obj1 now\n```\n\n#### 如果数组在迭代时被修改了，则其他元素会被跳过\n下面的例子输出'one', 'two', 'four'。当到达包含值'two'的项时，整个数组的第一个项被移除了，这导致所有剩下的项上移一个位置。因为元素 'four'现在在数组更前的位置，'three'会被跳过。 `forEach()`不会在迭代之前创建数组的副本。\n```js\nvar words = ['one', 'two', 'three', 'four'];\nwords.forEach(function(word) {\n    console.log(word);\n    if (word === 'two') {\n        words.shift();\n    }\n});\n// one\n// two\n// four\n```\n\n## Object.keys()\n`Object.keys()`方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用`for...in`循环遍历该对象时返回的顺序一致（两者的主要区别是：`for-in`循环还会枚举其原型链上的属性）。\n\n### 语法\n```js\nObject.keys(obj)\n```\nobj：要返回其枚举自身属性的对象；  \n返回值：一个表示给定对象的所有可枚举属性的字符串数组；\n\n### 示例\n```js\n/* Array 对象 */ \nlet arr = ['a', 'b', 'c'];\nconsole.log(Object.keys(arr)); \n// ['0', '1', '2']\n\n/* Object 对象 */ \nlet obj = { foo: 'bar', baz: 42 }, \n    keys = Object.keys(obj);\n// CCAC: Chrome Console Auto Copy\ncopy(keys); \n// ['foo','baz']\n\n/* 类数组 对象 */ \nlet obj = { 0 : 'a', 1 : 'b', 2 : 'c'};\nconsole.log(Object.keys(obj)); \n// ['0', '1', '2']\n\n// 类数组 对象, 随机 key 排序 \nlet anObj = { 100: 'a', 2: 'b', 7: 'c' }; \n\nconsole.log(Object.keys(anObj)); \n// ['2', '7', '100']\n\n/* getFoo 是个不可枚举的属性 */ \nvar my_obj = Object.create(\n   {}, \n   { getFoo : { value : function () { return this.foo } } }\n);\nmy_obj.foo = 1;\n\nconsole.log(Object.keys(my_obj)); \n// ['foo']\n```\n如果你想获取一个对象的所有属性,，甚至包括不可枚举的，使用`Object.getOwnPropertyNames`。\n\n### 注意\n在ES5里，如果此方法的参数不是对象（而是一个原始值），那么它会抛出`TypeError`。在ES2015中，非对象的参数将被强制转换为一个对象。\n```js\nObject.keys('foo');\n// TypeError: 'foo' is not an object (ES5 code)\n\nObject.keys('foo');\n// ['0', '1', '2']                   (ES2015 code)\n```\n\n## Object.getOwnPropertyNames\n`Object.getOwnPropertyNames()`方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括`Symbol`值作为名称的属性）组成的数组。\n\n### 语法\n```js\nObject.getOwnPropertyNames(obj)\n```\nobj：一个对象，其自身的可枚举和不可枚举属性的名称被返回；  \n返回值：在给定对象上找到的属性对应的字符串数组；\n\n### 描述\n`Object.getOwnPropertyNames()`返回一个数组，该数组对元素是obj自身拥有的枚举或不可枚举属性名称字符串。数组中枚举属性的顺序与通过`for...in`循环（或`Object.keys`）迭代该对象属性时一致。数组中不可枚举属性的顺序未定义。\n\n### 示例\n#### 使用Object.getOwnPropertyNames()\n```js\nvar arr = ['a', 'b', 'c'];\nconsole.log(Object.getOwnPropertyNames(arr).sort()); // ['0', '1', '2', 'length']\n\n// 类数组对象\nvar obj = { 0: 'a', 1: 'b', 2: 'c'};\nconsole.log(Object.getOwnPropertyNames(obj).sort()); // ['0', '1', '2']\n\n// 使用Array.forEach输出属性名和属性值\nObject.getOwnPropertyNames(obj).forEach(function(val, idx, array) {\n    console.log(val + ' -> ' + obj[val]);\n});\n// 输出\n// 0 -> a\n// 1 -> b\n// 2 -> c\n\n//不可枚举属性\nvar my_obj = Object.create({}, {\n    getFoo: {\n        value: function() { return this.foo; },\n        enumerable: false\n    }\n});\nmy_obj.foo = 1;\n\nconsole.log(Object.getOwnPropertyNames(my_obj).sort()); // ['foo', 'getFoo']\n```\n如果你只要获取到可枚举属性，查看`Object.keys`或用`for...in`循环（还会获取到原型链上的可枚举属性，不过可以使用`hasOwnProperty()`方法过滤掉）。\n\n#### 只获取不可枚举的属性\n```js\nvar target = myObject;\nvar enum_and_nonenum = Object.getOwnPropertyNames(target);\nvar enum_only = Object.keys(target);\nvar nonenum_only = enum_and_nonenum.filter(function(key) {\n    var indexInEnum = enum_only.indexOf(key);\n    if (indexInEnum == -1) {\n        // not found in enum_only keys mean the key is non-enumerable,\n        // so return true so we keep this in the filter\n        return true;\n    } else {\n        return false;\n    }\n});\n\nconsole.log(nonenum_only);\n```\n\n#### 提示\n在ES5中，如果参数不是一个原始对象类型，将抛出一个`TypeError`异常。在ES2015中，非对象参数被强制转换为对象 。\n```js\nObject.getOwnPropertyNames('foo');\n// TypeError: 'foo' is not an object (ES5 code)\n\nObject.getOwnPropertyNames('foo');\n// ['length', '0', '1', '2']  (ES2015 code)\n```\n\n### Reference\n- [https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in)\n- [https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of)\n- [https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)\n- [https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys)\n- [https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames)\n"
        },
        {
            "id": "article-2",
            "title": "一道JavaScript面试题",
            "update_time": "2018-01-08",
            "category": "面试 柯里化",
            "body": "<p style='margin-bottom: 5px;'><span style='font-size: 17px;'><strong>题目如下</strong></span></p><p>将以下函数补充完整：</p><pre class='brush:js;toolbar:false'>function&nbsp;sum(a,&nbsp;b,&nbsp;c)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;\n}\n\nfunction&nbsp;currying(fn)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;\n}\n\nvar&nbsp;curry&nbsp;=&nbsp;currying(sum);\nconsole.log(currying(sum,&nbsp;1,&nbsp;2,&nbsp;3));&nbsp;//&nbsp;6\nconsole.log(curry(1)(2)(3));&nbsp;//&nbsp;6\nconsole.log(curry(1,&nbsp;2)(3));&nbsp;//&nbsp;6\nconsole.log(curry()(1)(2)(3));&nbsp;//&nbsp;6\nconsole.log(curry(1,&nbsp;2,&nbsp;3));&nbsp;//&nbsp;6</pre><p>该题主要考察函数柯里化，关于柯里化的介绍参考<a href='http://hanyuehui.site/article-detail/25' target='_blank' _href='http://hanyuehui.site/article-detail/25'>这里</a>。</p><p style='margin-top: 10px;'><strong><span style='font-size: 17px;'>答案如下</span></strong></p><pre class='brush:js;toolbar:false'>function&nbsp;sum(a,&nbsp;b,&nbsp;c)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;a&nbsp;+&nbsp;b&nbsp;+&nbsp;c;\n}\n\nfunction&nbsp;currying(fn)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;args&nbsp;=&nbsp;typeof&nbsp;fn&nbsp;===&nbsp;&#39;number&#39;&nbsp;?&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[].slice.call(arguments)&nbsp;:&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[].slice.call(arguments,&nbsp;1);\n\n&nbsp;&nbsp;&nbsp;&nbsp;if(args.length&nbsp;==&nbsp;3)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;sum.apply(null,&nbsp;args);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;function()&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;innerArgs&nbsp;=&nbsp;Array.prototype.slice.call(arguments),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finalArgs&nbsp;=&nbsp;args.concat(innerArgs);\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;currying.apply(null,&nbsp;finalArgs)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}\n\nvar&nbsp;curry&nbsp;=&nbsp;currying(sum);\nconsole.log(currying(sum,&nbsp;1,&nbsp;2,&nbsp;3));&nbsp;//&nbsp;6\nconsole.log(curry(1)(2)(3));&nbsp;//&nbsp;6\nconsole.log(curry(1,&nbsp;2)(3));&nbsp;//&nbsp;6\nconsole.log(curry()(1)(2)(3));&nbsp;//&nbsp;6\nconsole.log(curry(1,&nbsp;2,&nbsp;3));&nbsp;//&nbsp;6</pre>"
        },
        {
            "id": "article-3",
            "title": "React消息传递",
            "update_time": "2018-01-10",
            "category": "react",
            "body": "<p>在React中，数据流动是单向的(<strong>单向数据流</strong>)，父组件通过props将数据传递到子组件，子组件根据父组件传递来的属性和组件内部状态来确定如何渲染。</p><p style='margin-top: 5px;'>因为单向数据流的特性，父组件向子组件传递数据是很容易的，即通过props传递数据，且子组件不能修改自己的props；父组件向孙子组件或者后代组件传递数据同样可以利用props进行层层传递。</p><p style='margin-top: 5px;'>但是，开发过程中我们会遇到各种各样的情况，譬如子组件向父组件传递消息、兄弟组件之间传递消息等，下面我们看一下如何进行组件之间的消息传递。</p><p><br/></p><p style='margin-bottom: 5px;'><span style='font-size: 18px;'><strong>父子组件之间进行消息传递</strong></span></p><p style='margin-top: 5px;'>React是单向数据流的，父组件向子组件传递消息可以通过props进行传递：</p><pre class='brush:js;toolbar:false'>class&nbsp;Child&nbsp;extends&nbsp;React.Component&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;render()&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(this.props.value);&nbsp;&nbsp;//&nbsp;123\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{this.props.value}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}\n\nclass&nbsp;Parent&nbsp;extends&nbsp;React.Component&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;render()&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Child&nbsp;value=&quot;123&quot;&nbsp;/&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}\n\nReactDOM.render(&lt;Parent&nbsp;/&gt;,&nbsp;document.getElementById(&#39;react-root&#39;));</pre><p>子组件向父组件传递消息也是通过props，因为在JavaScript中函数是<strong>一等公民</strong>，函数本身既可以像其他对象一样作为prop被传递到子组件，也可以在子组件中被直接调用。</p><p>因此，我们可以向子组件传递一个<strong>callback</strong>，子组件通过调用这个<strong>callback</strong>来向父组件中传递数据。</p><pre class='brush:js;toolbar:false'>class&nbsp;Child&nbsp;extends&nbsp;React.Component&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;render()&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(this.props.value);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;onChange={this.props.handleChange}/&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}\n\nclass&nbsp;Parent&nbsp;extends&nbsp;React.Component&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;render()&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Child&nbsp;handleChange={(e)&nbsp;=&gt;&nbsp;{console.log(e.target.value)}}&nbsp;/&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}\n\nReactDOM.render(&lt;Parent/&gt;,&nbsp;document.getElementById(&#39;react-root&#39;));</pre><p><br/></p><p style='margin-bottom: 5px;'><span style='font-size: 18px;'><strong>兄弟组件之间进行消息传递</strong></span></p><p style='margin-top: 5px;'>兄弟组件不能直接通过props进行消息传递，但是兄弟组件有相同的父元素，因此可以将需要传递的数据挂载在父组件中，由两个兄弟组件共享。</p><p>父组件通过props将数据传递给两个子组件，如果某个组件需要改变数据并通知其兄弟组件，则通过父组件传递<strong>callback</strong>给子组件来实现。</p><pre class='brush:js;toolbar:false'>class&nbsp;Panel&nbsp;extends&nbsp;React.Component&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;render()&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(this.props.value);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;{this.props.value}&lt;/div&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}\n\nclass&nbsp;Input&nbsp;extends&nbsp;React.Component&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;render()&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;onChange={this.props.handleChange}/&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}\n\nclass&nbsp;Parent&nbsp;extends&nbsp;React.Component&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;constructor(props)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(props);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.state&nbsp;=&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value:&nbsp;&#39;&#39;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;render()&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Panel&nbsp;value={this.state.value}&nbsp;/&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Input&nbsp;handleChange={\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(e)&nbsp;=&gt;&nbsp;{this.setState({value:&nbsp;e.target.val…;React.Component&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;getChildContext()&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VALUE:&nbsp;123\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;render()&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;SubParent&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Child&nbsp;/&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Child&nbsp;/&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/SubParent&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}\n\nParent.childContextTypes&nbsp;=&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;VALUE:&nbsp;React.PropTypes.number\n}\n\nReactDOM.render(&lt;Parent&nbsp;/&gt;,&nbsp;document.getElementById(&#39;react-root&#39;));</pre><p><br/></p><p style='margin-bottom: 5px;'><span style='font-size: 18px;'><strong>Redux</strong></span></p><p style='margin-top: 5px;'>为了能够更加清晰高效地管理React应用的数据，Facebook开源React的同时，也推出了Flux架构。Redux是Flux的一种优化实现，在Flux的&quot;单向数据流&quot;原则之上，Redux附加了另外三个原则：</p><ul class=' list-paddingleft-2' style='list-style-type: circle;'><li><p><strong>唯一数据源</strong></p></li><li><p><strong>状态只读</strong></p></li><li><p><strong>数据改变只能通过纯函数完成</strong></p></li></ul><p style='margin-top: 5px; margin-bottom: 5px;'><strong>唯一数据源</strong></p><p style='margin-bottom: 5px;'><strong></strong></p><p>唯一数据源指应用的状态数据应该只存储在唯一的<strong>Store</strong>上(Redux没有禁止创建多个Store，而是认为多个Store不会带来好处)。</p><p style='margin-top: 5px;'><strong>保持状态只读</strong></p><p>保持状态只读指不能直接修改状态，而是通过派发<strong>action</strong>的方式修改，这一点与<strong>Flux</strong>类似。</p><p style='margin-top: 5px;'><strong>数据改变只能通过纯函数完成</strong></p><p>纯函数指<strong>Reducer</strong>：</p><pre class='brush:js;toolbar:false'>reducer(state,&nbsp;action)</pre><p><strong>reducer</strong>根据<strong>state</strong>和<strong>action</strong>的值产生一个新对象，作为新的state(对应模块下的新state)，而不是直接修改原来的state。<strong>reducer</strong>只负责计算新状态，而不负责存储状态。</p><pre class='brush:js;toolbar:false'>const&nbsp;reducer&nbsp;=&nbsp;(state&nbsp;=&nbsp;{},&nbsp;action)&nbsp;=&gt;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;switch(action.type)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;&#39;1&#39;:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...state,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;status:&nbsp;1\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;&#39;2&#39;:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...state,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;status:&nbsp;2\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;&#39;3&#39;:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...state,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;status:&nbsp;3\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;state\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}</pre><p style='margin-bottom: 5px;'>下面这张图诠释了Redux的作用：</p><p><img src='/images/article/927434282006351872.jpg' title=' _src='/images/article/927434282006351872.jpg' alt='demo11_1.jpg'/><img src='/static/ueditor/themes/default/images/spacer.gif' word_img='file:///g%3A/React/react-demo/demo/images/demo11_1.jpg' style='background:url(/static/ueditor/lang/zh-cn/images/localimage.png) no-repeat center center;border:1px solid #ddd'/><br/></p><p><br/></p><p>关于Redux的使用可以看这里：<strong><a href='http://redux.js.org/' target='_blank' _href='http://redux.js.org/'>Redux官网</a></strong></p>"
        },
        {
            "id": "article-4",
            "title": "React事件系统",
            "update_time": "2018-01-18",
            "category": "react",
            "body": "<p style=\"margin-bottom: 5px;\"><span style=\"font-size: 18px;\"><strong>简介</strong></span></p><hr/><p style=\"margin-top: 5px;\">原生DOM事件体系存在很多问题，譬如各浏览器之间存在差异、容易引起内存浪费、性能低下、JS操作DOM效率低等。为了解决这些问题，React实现了一套比较高效的事件合成系统，包括事件注册、存储、分发、重用等功能。</p><p style=\"margin-bottom: 3px; margin-top: 2px;\">与原生DOM事件体系相比，React事件合成系统有如下特点：</p><ul class=\" list-paddingleft-2\" style=\"list-style-type: circle;\"><li><p style=\"margin-bottom: 2px;\"><strong>事件委托技术<br/></strong></p></li><li><p style=\"margin-bottom: 2px;\"><strong>事件冒泡机制</strong></p></li><li><p style=\"margin-bottom: 2px;\"><strong>合成事件<br/></strong></p></li><li><p style=\"margin-bottom: 2px;\"><strong>事件池</strong></p><p></p></li></ul><p><br/></p><p style=\"margin-bottom: 5px;\"><span style=\"font-size: 17px;\"><strong>事件委托技术</strong></span></p><p>在React组件上声明的事件最终都转化为原生事件并绑定到<strong>document</strong>上，而不是React组件对应的DOM节点。所以只有<strong>document</strong>节点绑定了原生事件。这样简化了事件体系，减少了内存开销。<br/></p><p><br/></p><p style=\"margin-bottom: 5px;\"><span style=\"font-size: 17px;\"><strong>事件冒泡机制</strong></span></p><p>原生DOM事件体系“DOM2级事件”规定的事件流包括三个阶段: 事件捕获阶段、处于目标阶段和事件冒泡阶段 。而React自身实现了一套事件冒泡机制，以队列的方式，从触发事件的组件向父组件回溯，调用在组件上绑定的事件处理函数。调用<strong>event.stopPropagation()</strong>可以阻止React事件体系中的冒泡行为，但是不能阻止原生事件的冒泡。相反，如果阻止了原生事件中的冒泡行为，React合成事件中的冒泡行为也会被阻止。</p><pre class=\"brush:js;toolbar:false\">class&nbsp;EventTest&nbsp;extends&nbsp;React.Component&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;constructor(props)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(props);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.handleClick&nbsp;=&nbsp;this.handleClick.bind(this);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.handleParentClick&nbsp;=&nbsp;this.handleParentClick.bind(this);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;componentDidMount()&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.button.addEventListener(&#39;click&#39;,&nbsp;function(e)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.stopPropagation();&nbsp;//&nbsp;调用原生事件的stopPropagation，只能输出&nbsp;3\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(3);&nbsp;//&nbsp;3\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.parent.addEventListener(&#39;click&#39;,&nbsp;function(e)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(4);&nbsp;//&nbsp;没有输出\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;handleClick(e)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(1);&nbsp;//&nbsp;没有输出\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;handleParentClick(e)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(2);&nbsp;//&nbsp;没有输出\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;render()&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;parentStyle&nbsp;=&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;300,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height:&nbsp;300,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;background:&nbsp;&quot;red&quot;,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;textAlign:&nbsp;&quot;center&quot;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;onClick={this.handleParentClick}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ref={(parent)&nbsp;=&gt;&nbsp;{this.parent&nbsp;=&nbsp;parent}}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;style={parentStyle}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button&nbsp;onClick={this.handleClick}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;style={{width:&nbsp;80,&nbsp;height:&nbsp;30,&nbsp;background:&nbsp;&quot;green&quot;}}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ref={(button)&nbsp;=&gt;&nbsp;{this.button&nbsp;=&nbsp;button}}&gt;点我&lt;/button&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}\n\nReactDOM.render(&lt;EventTest&nbsp;/&gt;,&nbsp;document.getElementById(&#39;react-root&#39;));</pre><p>输出: 3<br/></p><pre class=\"brush:js;toolbar:false\">componentDidMount()&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;this.button.addEventListener(&#39;click&#39;,&nbsp;function(e)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(3);&nbsp;//&nbsp;3\n&nbsp;&nbsp;&nbs…ion\nboolean&nbsp;metaKey\nboolean&nbsp;repeat\nboolean&nbsp;shiftKey\nnumber&nbsp;which</pre><p><strong>Focus Events</strong></p><pre class=\"brush:js;toolbar:false\">onFocus&nbsp;onBlur</pre><p>属性</p><pre class=\"brush:js;toolbar:false\">DOMEventTarget&nbsp;relatedTarget</pre><p><strong>Form Events</strong></p><pre class=\"brush:js;toolbar:false\">onChange&nbsp;onInput&nbsp;onInvalid&nbsp;onSubmit</pre><p><strong>Mouse Events</strong></p><pre class=\"brush:js;toolbar:false\">onClick&nbsp;onContextMenu&nbsp;onDoubleClick&nbsp;onDrag&nbsp;onDragEnd&nbsp;onDragEnter&nbsp;onDragExit\nonDragLeave&nbsp;onDragOver&nbsp;onDragStart&nbsp;onDrop&nbsp;onMouseDown&nbsp;onMouseEnter&nbsp;onMouseUp\nonMouseMove&nbsp;onMouseOut&nbsp;onMouseOver&nbsp;onMouseLeave</pre><p><strong>onMouseEnter</strong>和<strong>onMouseLeave</strong>事件从离开的元素到进入的元素传播而不是普通的冒泡方式，并且不存在捕获阶段。</p><p style=\"margin-top: 5px;\">属性</p><pre class=\"brush:js;toolbar:false\">boolean&nbsp;altKey\nnumber&nbsp;button\nnumber&nbsp;buttons\nnumber&nbsp;clientX\nnumber&nbsp;clientY\nboolean&nbsp;ctrlKey\nboolean&nbsp;getModifierState(key)\nboolean&nbsp;metaKey\nnumber&nbsp;pageX\nnumber&nbsp;pageY\nDOMEventTarget&nbsp;relatedTarget\nnumber&nbsp;screenX\nnumber&nbsp;screenY\nboolean&nbsp;shiftKey</pre><p><strong>Selection Events</strong></p><pre class=\"brush:js;toolbar:false\">onSelect</pre><p><strong>Touch Events</strong></p><pre class=\"brush:js;toolbar:false\">onTouchCancel&nbsp;onTouchEnd&nbsp;onTouchMove&nbsp;onTouchStart</pre><p>属性</p><pre class=\"brush:js;toolbar:false\">boolean&nbsp;altKey\nDOMTouchList&nbsp;changedTouches\nboolean&nbsp;ctrlKey\nboolean&nbsp;getModifierState(key)\nboolean&nbsp;metaKey\nboolean&nbsp;shiftKey\nDOMTouchList&nbsp;targetTouches\nDOMTouchList&nbsp;touches</pre><p><strong>UI Events</strong></p><pre class=\"brush:js;toolbar:false\">onScroll</pre><p>属性</p><pre class=\"brush:js;toolbar:false\">number&nbsp;detail\nDOMAbstractView&nbsp;view</pre><p><strong>Wheel Events</strong></p><pre class=\"brush:js;toolbar:false\">onWheel</pre><p>属性</p><pre class=\"brush:js;toolbar:false\">number&nbsp;deltaMode\nnumber&nbsp;deltaX\nnumber&nbsp;deltaY\nnumber&nbsp;deltaZ</pre><p><strong>Media Events</strong></p><pre class=\"brush:js;toolbar:false\">onAbort&nbsp;onCanPlay&nbsp;onCanPlayThrough&nbsp;onDurationChange&nbsp;onEmptied&nbsp;onEncrypted\nonEnded&nbsp;onError&nbsp;onLoadedData&nbsp;onLoadedMetadata&nbsp;onLoadStart&nbsp;onPause&nbsp;onPlay\nonPlaying&nbsp;onProgress&nbsp;onRateChange&nbsp;onSeeked&nbsp;onSeeking&nbsp;onStalled&nbsp;onSuspend\nonTimeUpdate&nbsp;onVolumeChange&nbsp;onWaiting</pre><p><strong>Image Events</strong></p><pre class=\"brush:js;toolbar:false\">onLoad&nbsp;onError</pre><p><strong>Animation Events</strong></p><pre class=\"brush:js;toolbar:false\">onAnimationStart&nbsp;onAnimationEnd&nbsp;onAnimationIteration</pre><p>属性</p><pre class=\"brush:js;toolbar:false\">string&nbsp;animationName\nstring&nbsp;pseudoElement\nfloat&nbsp;elapsedTime</pre><p><strong>Transition Events</strong></p><pre class=\"brush:js;toolbar:false\">onTransitionEnd</pre><p>属性</p><pre class=\"brush:js;toolbar:false\">string&nbsp;propertyName\nstring&nbsp;pseudoElement\nfloat&nbsp;elapsedTime</pre><p><strong>Other Events</strong></p><pre class=\"brush:js;toolbar:false\">onToggle</pre><p><br/></p><p style=\"margin-bottom: 5px;\"><span style=\"font-size: 18px;\"><strong>React事件系统</strong></span></p><hr/><p style=\"margin-top: 5px;\">先看 Facebook 给出的React事件系统框图:&nbsp;</p><p style=\"margin-top: 5px;\"><img src=\"/images/article/919911412627804160.png\" title=\"\" _src=\"/images/article/919911412627804160.png\" alt=\"6AORW(X3(Z$8(WN~J898(]M.png\"/></p><p style=\"margin-top: 5px;\">浏览器事件(如用户点击了某个button)触发后，DOM将event传给<strong>ReactEventListener</strong>，它将事件分发到当前组件及以上的父组件。然后由<strong>ReactEventEmitter</strong>对每个组件进行事件的执行，先构造React合成事件，然后以<strong>queue</strong>的方式调用组件中声明的事件处理函数。</p><p style=\"margin-top: 5px;\">涉及到的主要类如下:&nbsp;</p><ul class=\" list-paddingleft-2\" style=\"list-style-type: circle;\"><li><p><strong>ReactEventListener:&nbsp;</strong>负责事件注册和事件分发。React将DOM事件全都注册到document这个节点上。事件分发主要调用<strong>dispatchEvent</strong>进行，从事件触发组件开始，向父元素遍历</p></li><li><p><strong>ReactEventEmitter:</strong> 负责每个组件上事件的执行</p></li><li><p><strong>EventPluginHub:</strong> 负责事件的存储，合成事件以对象池的方式实现创建和销毁，大大提高了性能</p></li><li><p><strong>SimpleEventPlugin等plugin:</strong> 根据不同的事件类型，构造不同的合成事件。如focus对应的React合成事件为<strong>SyntheticFocusEvent</strong></p></li></ul><p><br/></p><p style=\"margin-bottom: 2px;\"><span style=\"white-space: normal;\">React事件体系源码分析看&nbsp;</span><a href=\"https://zhuanlan.zhihu.com/p/25883536\" target=\"_blank\" _href=\"https://zhuanlan.zhihu.com/p/25883536\" style=\"white-space: normal;\"><strong>这里</strong></a></p><ul class=\" list-paddingleft-2\" style=\"list-style-type: circle;\"><li><p><strong>事件注册</strong></p></li><li><p><strong>事件存储</strong></p></li><li><p><strong>事件执行</strong></p></li></ul><p><br/></p><p><strong>Reference: </strong><strong><a href=\"https://reactjs.org/docs/events.html\" target=\"_blank\" _href=\"https://reactjs.org/docs/events.html\">React中文网</a></strong></p>"
        },
        {
            "id": "article-5",
            "title": "Immutable 详解",
            "update_time": "2018-02-18",
            "category": "javascript",
            "body": "## 数据类型 \n ECMAScript中的数据类型分为两类：简单数据类型（也称为基本数据类型）和复杂数据类型（对象）： - Primitive Data Types（基础数据类型）: String, Number, Boolean, Null, Undefine ..."
        },
        {
            "id": "article-6",
            "title": "React Fiber",
            "update_time": "2018-02-20",
            "category": "react",
            "body": "## 问题 \n ### Fiber的目标 > Increase its suitability for areas like animation, layout, and gestures. ### React Fiber > React Fiber is ..."
        }
    ],
    "drops": [
        {
            "created_at": "2018-02-08",
            "detail": "<p><strong>.\\mongodump.exe -d twitter -c typical -u user -p passoword</strong></p>",
            "id": 38,
            "tag": "mongodump",
            "title": "MongoDB转储数据"
        },
        {
            "created_at": "2017-12-25",
            "detail": "<p><a href=\"https://imjad.cn\" target=\"_blank\" _href=\"https://imjad.cn\"><strong>https://imjad.cn</strong></a></p><p><a href=\"https://tucao.moe/\" target=\"_blank\" _href=\"https://tucao.moe/\"><strong>https://tucao.moe/</strong></a></p><p><a href=\"https://haremu.com/p/205\" target=\"_blank\" _href=\"https://haremu.com/p/205\"><strong>https://haremu.com/p/205</strong></a></p>",
            "id": 37,
            "tag": "Live2D",
            "title": "Live2D"
        },
        {
            "created_at": "2017-11-30",
            "detail": "<p><strong>Runtime指用于支持程序运行时的组件，它可以是Engine和/或VM；</strong></p><p><strong>Engine时一种处理抽象，它负责将代码变为底层可执行代码；</strong></p><p><strong>VM时一种系统抽象，它提供代码执行所需要的API环境；</strong></p>",
            "id": 36,
            "tag": "Runtime Engine VM",
            "title": "Runtime、Engine、VM的区别"
        },
        {
            "created_at": "2017-11-22",
            "detail": "<p><strong>mongod.exe --auth --logpath=&quot;C:/data/log/log.txt&quot; --wiredTigerCacheSizeGB 1.5</strong></p>",
            "id": 35,
            "tag": "MongoDB 缓存",
            "title": "MonoDB设置缓存"
        },
        {
            "created_at": "2017-11-12",
            "detail": "<p><a href=\"http://blog.csdn.net/u012162613/article/details/48323777\" target=\"_blank\" _href=\"http://blog.csdn.net/u012162613/article/details/48323777\"><strong>朴素贝叶斯理论理论推导与三种常见模型</strong></a><br/></p>",
            "id": 34,
            "tag": "朴素贝叶斯",
            "title": "朴素贝叶斯理论理论推导与三种常见模型"
        },
        {
            "created_at": "2017-09-26",
            "detail": "<p><a href=\"http://www.cnblogs.com/eastmount/p/5052871.html\" target=\"_blank\" _href=\"http://www.cnblogs.com/eastmount/p/5052871.html\"><strong><span style=\"color: rgb(34, 34, 34); font-family: &quot;Helvetica Neue For Number&quot;, -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-size: 15px; white-space: normal; word-spacing: 2px; background-color: rgb(249, 249, 249);\">安装numpy+scipy+matlotlib+scikit-learn及问题解决</span></strong></a></p>",
            "id": 26,
            "tag": "scikit-learn",
            "title": "安装numpy+scipy+matlotlib+scikit-learn及问题解决"
        },
        {
            "created_at": "2017-09-26",
            "detail": "<p><strong>py2neo教程:</strong></p><p><a href=\"http://py2neo.org/v3/database.html\" target=\"_blank\" _href=\"http://py2neo.org/v3/database.html\"><strong>官网: http://py2neo.org/v3/database.html</strong></a></p><p><a href=\"http://www.jianshu.com/p/a2497a33390f\" target=\"_blank\" _href=\"http://www.jianshu.com/p/a2497a33390f\"><strong>简易教程: http://www.jianshu.com/p/a2497a33390f</strong></a></p><p><a href=\"http://py2neo.org/v3/_modules/py2neo/database.html\" target=\"_blank\" _href=\"http://py2neo.org/v3/_modules/py2neo/database.html\"><strong>源代码:&nbsp;http://py2neo.org/v3/_modules/py2neo/database.html</strong></a></p><p><br/></p><p><strong>neo4j教程:</strong></p><p><a href=\"https://www.w3cschool.cn/neo4j/neo4j_cql_where_clause.html\" target=\"_blank\" _href=\"https://www.w3cschool.cn/neo4j/neo4j_cql_where_clause.html\"><strong>https://www.w3cschool.cn/neo4j/neo4j_cql_where_clause.html</strong></a></p><p><br/></p><p><strong>Cypher教程:</strong></p><p><strong><a href=\"http://www.rm5u.com/neo4j/neo-cypher-18.html\" target=\"_blank\" _href=\"http://www.rm5u.com/neo4j/neo-cypher-18.html\">http://www.rm5u.com/neo4j/neo-cypher-18.html</a></strong></p><p><br/></p><p><strong>关系查询:</strong></p><p><strong><a href=\"http://www.zhimengzhe.com/shujuku/other/168933.html\" target=\"_blank\" _href=\"http://www.zhimengzhe.com/shujuku/other/168933.html\">http://www.zhimengzhe.com/shujuku/other/168933.html</a></strong></p><p><br/></p><p style=\"margin-bottom: 5px;\"><strong>关系导入:</strong></p><blockquote><p style=\"margin-bottom: 5px;\"><strong>load csv with headers from &quot;file:///nflMixed.csv&quot; as line<br/>create(:school{name:line.College})</strong></p></blockquote><p></p>",
            "id": 29,
            "tag": "neo4j",
            "title": "Neo4j 教程"
        },
        {
            "created_at": "2017-09-26",
            "detail": "<p><a href=\"http://www.cnblogs.com/yesuuu/p/6077463.html\" target=\"_blank\" _href=\"http://www.cnblogs.com/yesuuu/p/6077463.html\"><strong>import问题总结</strong></a></p><p><a href=\"http://blog.csdn.net/chinaren0001/article/details/7338041\" target=\"_blank\" _href=\"http://blog.csdn.net/chinaren0001/article/details/7338041\"><strong>Relative import 相对路径 ValueError</strong></a></p><p><a href=\"http://blog.csdn.net/liuxingen/article/details/52497023\" target=\"_blank\" _href=\"http://blog.csdn.net/liuxingen/article/details/52497023\"><strong>Python相对、绝对导入浅析</strong></a></p>",
            "id": 30,
            "tag": "python import",
            "title": "python import 问题"
        },
        {
            "created_at": "2017-09-26",
            "detail": "<p><a href=\"https://zhuanlan.zhihu.com/p/20495964\" target=\"_blank\" _href=\"https://zhuanlan.zhihu.com/p/20495964\"><strong>CSS Modules 详解</strong></a></p><p><strong><a href=\"https://www.zhihu.com/question/20187618?q=css%E6%A8%A1%E5%9D%97%E5%8C%96\" target=\"_blank\" _href=\"https://www.zhihu.com/question/20187618?q=css%E6%A8%A1%E5%9D%97%E5%8C%96\">CSS模块化（面向对象）和组件化</a></strong></p><p><a href=\"https://github.com/zhengweikeng/blog/issues/9\" target=\"_blank\" _href=\"https://github.com/zhengweikeng/blog/issues/9\"><strong>webpack中关于样式的处理</strong></a></p>",
            "id": 31,
            "tag": "CSS 模块化",
            "title": "CSS 模块化"
        },
        {
            "created_at": "2017-09-26",
            "detail": "<p><a href=\"http://www.alloyteam.com/2017/01/react-from-scratch-server-render/\" target=\"_blank\" _href=\"http://www.alloyteam.com/2017/01/react-from-scratch-server-render/\"><strong>从零开始React服务器渲染</strong></a></p><p><a href=\"http://www.jianshu.com/p/0ecd727107bb\" target=\"_blank\" _href=\"http://www.jianshu.com/p/0ecd727107bb\"><strong>教你搭建一个完美的服务端渲染开发环境</strong></a></p>",
            "id": 32,
            "tag": "React",
            "title": "React服务端渲染"
        }
    ]
}