{
    "posts": [{
        "id": 1,
        "title": "json-server",
        "author": "typicode"
    }],
    "articles": [{
        "id": "article-1",
        "article_id": "article-1",
        "title": "for..in for..of forEach",
        "update_time": "2018-01-04",
        "category": "Javascript",
        "abstract": "## for...in for...in语句以任意顺序遍历一个对象的可枚举属性。对于每个不同的属性，语句都会被执行。 ### 语法 ```js for (variable in object) {...} ``` `variable`：在每次迭代时，将不同的 ..."
    }, {
        "id": "article-2",
        "article_id": "article-2",
        "title": "一道JavaScript面试题",
        "update_time": "2018-01-08",
        "category": "面试 柯里化",
        "abstract": "题目如下将以下函数补充完整：function sum(a, b, c) { } function currying(fn) { } var curry = currying(sum); console.log(currying(sum, ..."
    }, {
        "id": "article-3",
        "article_id": "article-3",
        "title": "React消息传递",
        "update_time": "2018-01-10",
        "category": "react",
        "abstract": "在React中，数据流动是单向的(单向数据流)，父组件通过props将数据传递到子组件，子组件根据父组件传递来的属性和组件内部状态来确定如何渲染。因为单向数据流的特性，父组件向子组件传递数据是很容易的，即通过props传递数据，且子组件不能修改自己的props ..."
    }, {
        "id": "article-4",
        "article_id": "article-4",
        "title": "React事件系统",
        "update_time": "2018-01-18",
        "category": "react",
        "abstract": "简介原生DOM事件体系存在很多问题，譬如各浏览器之间存在差异、容易引起内存浪费、性能低下、JS操作DOM效率低等。为了解决这些问题，React实现了一套比较高效的事件合成系统，包括事件注册、存储、分发、重用等功能。与原生DOM事件体系相比，React事件合成系 ..."
    }, {
        "id": "article-5",
        "article_id": "article-5",
        "title": "Immutable 详解",
        "update_time": "2018-02-18",
        "category": "javascript",
        "abstract": "## 数据类型 ECMAScript中的数据类型分为两类：简单数据类型（也称为基本数据类型）和复杂数据类型（对象）： - Primitive Data Types（基础数据类型）: String, Number, Boolean, Null, Undefine ..."
    }, {
        "id": "article-6",
        "article_id": "article-6",
        "title": "React Fiber",
        "update_time": "2018-02-20",
        "category": "react",
        "abstract": "## 问题 ### Fiber的目标 > Increase its suitability for areas like animation, layout, and gestures. ### React Fiber > React Fiber is ..."
    }],
    "article_detail": [{
        "id": "article-1",
        "title": "for..in for..of forEach",
        "update_time": "2018-01-04",
        "category": "Javascript",
        "body": "## for...in↵for...in语句以任意顺序遍历一个对象的可枚举属性。对于每个不同的属性，语句都会被执行。↵↵### 语法↵```js↵for (variable in object) {...}↵```↵`variable`：在每次迭代时，将不同的属性名分配给变量。  ↵`object`：被迭代枚举其属性的对象。↵↵### 描述↵`for...in`循环只遍历可枚举属性，包括对象自身的可枚举属性，以及其原型链上的所有可枚举属性。↵↵#### 删除、添加、修改属性↵`for...in`循环以任意序迭代一个对象的属性，对属性的删除、添加、修改需要注意以下几个问题：↵- 如果一个属性在一次迭代中被修改，并在之后的迭代中被访问，那么再次被访问的值为修改之后的值；↵- 一个在被访问之前已经被删除的属性将不会在之后被访问；↵- 在迭代进行时被添加到对象的属性，可能在之后的迭代被访问，也可能被忽略；所以不能保证迭代时添加的属性一定能被访问到；↵- 因为迭代的顺序是不确定的，所以不能保证在迭代过程中被修改或被删除的属性会在修改或删除前还是修改或删除后被访问到（除非是正在被访问的属性）；↵- 所以，在迭代过程中最好不要在对象上进行添加、修改或者删除属性的操作，除非是对当前正在被访问的属性；↵↵#### 数组迭代↵`for...in`不应该用来迭代数组，因为通常情况下迭代数组时，顺序是很重要的，而数组索引只是具有整数名称的枚举属性，与通用对象属性相同，所以`for...in`不能保证有序迭代数组。↵↵另外，`for...in`将返回所有可枚举属性，包括非整数类型的属性以及继承自原型链上的属性。↵↵#### 仅迭代自身属性↵如果你只要考虑对象本身的属性，而不是它的原型，那么使用`getOwnPropertyNames()`或执行`hasOwnProperty()`来确定某属性是否是对象本身的属性↵```js↵for (var prop in obj) {↵    if (obj.hasOwnProperty(prop)) {↵        console.log(prop);↵    } ↵}↵```↵↵## for...of↵`for...of`语句是ES2015中新引入的，用于配合可迭代对象使用。↵↵`for...of`可以在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。↵↵### 语法↵```js↵for (variable of iterable) {↵    //statements↵}↵```↵`variable`：在每次迭代中，将不同属性的**值**分配给变量。  ↵`iterable`：可枚举其枚举属性的对象。↵↵### 示例↵```js↵let iterable = [10, 20, 30];↵↵for (const value of iterable) {↵    console.log(value);↵}↵// 10↵// 20↵// 30↵```↵```js↵let iterable = 'boo';↵↵for (let value of iterable) {↵   console.log(value);↵}↵// 'b'↵// 'o'↵// 'o'↵```↵```js↵let iterable = new Map([['a', 1], ['b', 2], ['c', 3]]);↵↵for (let entry of iterable) {↵  console.log(entry);↵}↵// ['a', 1]↵// ['b', 2]↵// ['c', 3]↵↵for (let [key, value] of iterable) {↵  console.log(value);↵}↵// 1↵// 2↵// 3↵```↵```js↵let iterable = new Set([1, 1, 2, 2, 3, 3]);↵↵for (let value of iterable) {↵    console.log(value);↵}↵// 1↵// 2↵// 3↵```↵↵## forEach↵`forEach()`方法是在第五版本里被添加到`ECMA-262`标准的，它可以对数组的每个元素执行一次提供的函数。↵↵### 语法↵```js↵array.forEach(callback(currentValue, index, array){↵    //do something↵}, this)↵↵array.forEach(callback[, thisArg])↵```↵`callback`：为数组中每个元素执行的函数，该函数接收三个参数：↵- currentValue(当前值)：数组中正在处理的当前元素；↵- index(索引)：数组中正在处理的当前元素的索引；↵- array：forEach()方法正在操作的数组；↵↵`thisArg`：可选参数，当执行回调函数时用作this的值(参考对象)；↵↵### 语法↵`forEach`方法按升序为数组中含有效值的每一项执行一次callback 函数，那些已删除（使用delete方法等情况）或者未初始化的项将被跳过（但不包括那些值为 undefined 的项）（例如在稀疏数组上）。↵↵callback函数会被依次传入三个参数：↵- 数组当前项的值↵- 数当前项的索引↵- 数组对象本身↵↵如果给forEach传递了thisArg参数，当调用时，它将被传给callback函数，作为它的this值。否则，将会传入undefined作为它的this值。↵↵`forEach`遍历的范围在第一次调用`callback`前就会确定。调用`forEach`后添加到数组中的项不会被`callback`访问到。如果已经存在的值被改变，则传递给`callback`的值是`forEach`遍历到它们那一刻的值。已删除的项不会被遍历到。如果已访问的元素在迭代时被删除了(例如使用 shift()) ，之后的元素将被跳过。↵↵`forEach()`为每个数组元素执行callback函数；不像`map()`或者`reduce()`，它总是返回`undefined`值，并且不可链式调用。↵↵**注意**：没有办法中止或者跳出forEach循环，除了抛出一个异常。如果你需要这样，使用forEach()方法是错误的，你可以用一个简单的循环作为替代。如果你正在测试一个数组里的元素是否符合某条件，且需要返回一个布尔值，那么可使用`Array.every`或`Array.some`。↵↵### 示例↵#### 打印数组内容↵```js↵function logArrayElements(element, index, array) {↵    console.log('a[' + index + '] = ' + element);↵}↵↵// 注意索引2被跳过了，因为在数组的这个位置没有项↵[2, 5, ,9].forEach(logArrayElements);↵↵// a[0] = 2↵// a[1] = 5↵// a[3] = 9↵↵[2, 5,' ,9].forEach(logArrayElements);↵// a[0] = 2↵// a[1] = 5↵// a[2] = ↵// a[3] = 9↵↵[2, 5, undefined ,9].forEach(logArrayElements);↵// a[0] = 2↵// a[1] = 5↵// a[2] = undefined↵// a[3] = 9↵↵let xxx;↵// undefined↵↵[2, 5, xxx ,9].forEach(logArrayElements);↵// a[0] = 2↵// a[1] = 5↵// a[2] = undefined↵// a[3] = 9↵```↵#### 使用thisArg↵```js↵function Counter() {↵    this.sum = 0;↵    this.count = 0;↵}↵↵Counter.prototype.add = function(array) {↵    array.forEach(function(entry) {↵        this.sum += entry;↵        ++this.count;↵    }, this);↵    //console.log(this);↵};↵↵var obj = new Counter();↵obj.add([1, 3, 5, 7]);↵↵obj.count; ↵// 4 === (1+1+1+1)↵obj.sum;↵// 16 === (1+3+5+7)↵```↵**注意**：如果使用箭头函数表达式传入函数参数，thisArg参数会被忽略，因为箭头函数在词法上绑定了this值。↵↵#### 对象复制函数↵```js↵function copy(obj) {↵    var copy = Object.create(Object.getPrototypeOf(obj));↵    var propNames = Object.getOwnPropertyNames(obj);↵↵    propNames.forEach(function(name) {↵        var desc = Object.getOwnPropertyDescriptor(obj, name);↵        Object.defineProperty(copy, name, desc);↵  });↵↵    return copy;↵}↵↵var obj1 = { a: 1, b: 2 };↵var obj2 = copy(obj1); // obj2 looks like obj1 now↵```↵↵#### 如果数组在迭代时被修改了，则其他元素会被跳过↵下面的例子输出'one', 'two', 'four'。当到达包含值'two'的项时，整个数组的第一个项被移除了，这导致所有剩下的项上移一个位置。因为元素 'four'现在在数组更前的位置，'three'会被跳过。 `forEach()`不会在迭代之前创建数组的副本。↵```js↵var words = ['one', 'two', 'three', 'four'];↵words.forEach(function(word) {↵    console.log(word);↵    if (word === 'two') {↵        words.shift();↵    }↵});↵// one↵// two↵// four↵```↵↵## Object.keys()↵`Object.keys()`方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用`for...in`循环遍历该对象时返回的顺序一致（两者的主要区别是：`for-in`循环还会枚举其原型链上的属性）。↵↵### 语法↵```js↵Object.keys(obj)↵```↵obj：要返回其枚举自身属性的对象；  ↵返回值：一个表示给定对象的所有可枚举属性的字符串数组；↵↵### 示例↵```js↵/* Array 对象 */ ↵let arr = ['a', 'b', 'c'];↵console.log(Object.keys(arr)); ↵// ['0', '1', '2']↵↵/* Object 对象 */ ↵let obj = { foo: 'bar', baz: 42 }, ↵    keys = Object.keys(obj);↵// CCAC: Chrome Console Auto Copy↵copy(keys); ↵// ['foo','baz']↵↵/* 类数组 对象 */ ↵let obj = { 0 : 'a', 1 : 'b', 2 : 'c'};↵console.log(Object.keys(obj)); ↵// ['0', '1', '2']↵↵// 类数组 对象, 随机 key 排序 ↵let anObj = { 100: 'a', 2: 'b', 7: 'c' }; ↵↵console.log(Object.keys(anObj)); ↵// ['2', '7', '100']↵↵/* getFoo 是个不可枚举的属性 */ ↵var my_obj = Object.create(↵   {}, ↵   { getFoo : { value : function () { return this.foo } } }↵);↵my_obj.foo = 1;↵↵console.log(Object.keys(my_obj)); ↵// ['foo']↵```↵如果你想获取一个对象的所有属性,，甚至包括不可枚举的，使用`Object.getOwnPropertyNames`。↵↵### 注意↵在ES5里，如果此方法的参数不是对象（而是一个原始值），那么它会抛出`TypeError`。在ES2015中，非对象的参数将被强制转换为一个对象。↵```js↵Object.keys('foo');↵// TypeError: 'foo' is not an object (ES5 code)↵↵Object.keys('foo');↵// ['0', '1', '2']                   (ES2015 code)↵```↵↵## Object.getOwnPropertyNames↵`Object.getOwnPropertyNames()`方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括`Symbol`值作为名称的属性）组成的数组。↵↵### 语法↵```js↵Object.getOwnPropertyNames(obj)↵```↵obj：一个对象，其自身的可枚举和不可枚举属性的名称被返回；  ↵返回值：在给定对象上找到的属性对应的字符串数组；↵↵### 描述↵`Object.getOwnPropertyNames()`返回一个数组，该数组对元素是obj自身拥有的枚举或不可枚举属性名称字符串。数组中枚举属性的顺序与通过`for...in`循环（或`Object.keys`）迭代该对象属性时一致。数组中不可枚举属性的顺序未定义。↵↵### 示例↵#### 使用Object.getOwnPropertyNames()↵```js↵var arr = ['a', 'b', 'c'];↵console.log(Object.getOwnPropertyNames(arr).sort()); // ['0', '1', '2', 'length']↵↵// 类数组对象↵var obj = { 0: 'a', 1: 'b', 2: 'c'};↵console.log(Object.getOwnPropertyNames(obj).sort()); // ['0', '1', '2']↵↵// 使用Array.forEach输出属性名和属性值↵Object.getOwnPropertyNames(obj).forEach(function(val, idx, array) {↵    console.log(val + ' -> ' + obj[val]);↵});↵// 输出↵// 0 -> a↵// 1 -> b↵// 2 -> c↵↵//不可枚举属性↵var my_obj = Object.create({}, {↵    getFoo: {↵        value: function() { return this.foo; },↵        enumerable: false↵    }↵});↵my_obj.foo = 1;↵↵console.log(Object.getOwnPropertyNames(my_obj).sort()); // ['foo', 'getFoo']↵```↵如果你只要获取到可枚举属性，查看`Object.keys`或用`for...in`循环（还会获取到原型链上的可枚举属性，不过可以使用`hasOwnProperty()`方法过滤掉）。↵↵#### 只获取不可枚举的属性↵```js↵var target = myObject;↵var enum_and_nonenum = Object.getOwnPropertyNames(target);↵var enum_only = Object.keys(target);↵var nonenum_only = enum_and_nonenum.filter(function(key) {↵    var indexInEnum = enum_only.indexOf(key);↵    if (indexInEnum == -1) {↵        // not found in enum_only keys mean the key is non-enumerable,↵        // so return true so we keep this in the filter↵        return true;↵    } else {↵        return false;↵    }↵});↵↵console.log(nonenum_only);↵```↵↵#### 提示↵在ES5中，如果参数不是一个原始对象类型，将抛出一个`TypeError`异常。在ES2015中，非对象参数被强制转换为对象 。↵```js↵Object.getOwnPropertyNames('foo');↵// TypeError: 'foo' is not an object (ES5 code)↵↵Object.getOwnPropertyNames('foo');↵// ['length', '0', '1', '2']  (ES2015 code)↵```↵↵### Reference↵- [https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in)↵- [https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of)↵- [https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)↵- [https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys)↵- [https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames)↵"
    }]
}